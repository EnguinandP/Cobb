@article{Poirot,
  author     = {Zhou, Zhe and Mishra, Ashish and Delaware, Benjamin and Jagannathan, Suresh},
  title      = {Covering All the Bases: Type-Based Verification of Test Input Generators},
  year       = {2023},
  issue_date = {June 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {PLDI},
  url        = {https://doi.org/10.1145/3591271},
  doi        = {10.1145/3591271},
  abstract   = {Test input generators are an important part of property-based testing (PBT) frameworks. Because PBT is intended to test deep semantic and structural properties of a program, the outputs produced by these generators can be complex data structures, constrained to satisfy properties the developer believes is most relevant to testing the function of interest. An important feature expected of these generators is that they be capable of producing all acceptable elements that satisfy the function’s input type and generator-provided constraints. However, it is not readily apparent how we might validate whether a particular generator’s output satisfies this coverage requirement. Typically, developers must rely on manual inspection and post-mortem analysis of test runs to determine if the generator is providing sufficient coverage; these approaches are error-prone and difficult to scale as generators become more complex. To address this important concern, we present a new refinement type-based verification procedure for validating the coverage provided by input test generators, based on a novel interpretation of types that embeds “must-style” underapproximate reasoning principles as a fundamental part of the type system. The types associated with expressions now capture the set of values guaranteed to be produced by the expression, rather than the typical formulation that uses types to represent the set of values an expression may produce. Beyond formalizing the notion of coverage types in the context of a rich core language with higher-order procedures and inductive datatypes, we also present a detailed evaluation study to justify the utility of our ideas.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jun},
  articleno  = {157},
  numpages   = {24},
  keywords   = {property-based testing, refinement types, underapproximate reasoning}
}

@article{IL,
	author = {O'Hearn, Peter W.},
	title = {Incorrectness Logic},
	year = {2019},
	issue_date = {January 2020},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {4},
	number = {POPL},
	url = {https://doi.org/10.1145/3371078},
	doi = {10.1145/3371078},
	abstract = {Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness.},
	journal = {Proc. ACM Program. Lang.},
	month = {dec},
	articleno = {10},
	numpages = {32},
	keywords = {none}
}

@misc{li2023efficient,
  title         = {Efficient Bottom-Up Synthesis for Programs with Local Variables},
  author        = {Xiang Li and Xiangyu Zhou and Rui Dong and Yihong Zhang and Xinyu Wang},
  year          = {2023},
  eprint        = {2311.03705},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}