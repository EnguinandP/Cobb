@article{Burst,
  author     = {Miltner, Anders and Nu\~{n}ez, Adrian Trejo and Brendel, Ana and Chaudhuri, Swarat and Dillig, Isil},
  title      = {Bottom-up Synthesis of Recursive Functional Programs Using Angelic Execution},
  year       = {2022},
  issue_date = {January 2022},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {6},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3498682},
  doi        = {10.1145/3498682},
  abstract   = {We present a novel bottom-up method for the synthesis of functional recursive programs. While bottom-up synthesis techniques can work better than top-down methods in certain settings, there is no prior technique for synthesizing recursive programs from logical specifications in a purely bottom-up fashion. The main challenge is that effective bottom-up methods need to execute sub-expressions of the code being synthesized, but it is impossible to execute a recursive subexpression of a program that has not been fully constructed yet. In this paper, we address this challenge using the concept of angelic semantics. Specifically, our method finds a program that satisfies the specification under angelic semantics (we refer to this as angelic synthesis), analyzes the assumptions made during its angelic execution, uses this analysis to strengthen the specification, and finally reattempts synthesis with the strengthened specification. Our proposed angelic synthesis algorithm is based on version space learning and therefore deals effectively with many incremental synthesis calls made during the overall algorithm. We have implemented this approach in a prototype called Burst and evaluate it on synthesis problems from prior work. Our experiments show that Burst is able to synthesize a solution to 94\% of the benchmarks in our benchmark suite, outperforming prior work.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jan},
  articleno  = {21},
  numpages   = {29},
  keywords   = {Angelic Execution, Logical Specifications, Program Synthesis}
}

@article{IL,
  author     = {O'Hearn, Peter W.},
  title      = {Incorrectness Logic},
  year       = {2019},
  issue_date = {January 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {POPL},
  url        = {https://doi.org/10.1145/3371078},
  doi        = {10.1145/3371078},
  abstract   = {Program correctness and incorrectness are two sides of the same coin. As a programmer, even if you would like to have correctness, you might find yourself spending most of your time reasoning about incorrectness. This includes informal reasoning that people do while looking at or thinking about their code, as well as that supported by automated testing and static analysis tools. This paper describes a simple logic for program incorrectness which is, in a sense, the other side of the coin to Hoare's logic of correctness.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {dec},
  articleno  = {10},
  numpages   = {32},
  keywords   = {none}
}

@misc{li2023efficient,
  title         = {Efficient Bottom-Up Synthesis for Programs with Local Variables},
  author        = {Xiang Li and Xiangyu Zhou and Rui Dong and Yihong Zhang and Xinyu Wang},
  year          = {2023},
  eprint        = {2311.03705},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}

@article{Poirot,
  author     = {Zhou, Zhe and Mishra, Ashish and Delaware, Benjamin and Jagannathan, Suresh},
  title      = {Covering All the Bases: Type-Based Verification of Test Input Generators},
  year       = {2023},
  issue_date = {June 2023},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {7},
  number     = {PLDI},
  url        = {https://doi.org/10.1145/3591271},
  doi        = {10.1145/3591271},
  abstract   = {Test input generators are an important part of property-based testing (PBT) frameworks. Because PBT is intended to test deep semantic and structural properties of a program, the outputs produced by these generators can be complex data structures, constrained to satisfy properties the developer believes is most relevant to testing the function of interest. An important feature expected of these generators is that they be capable of producing all acceptable elements that satisfy the function’s input type and generator-provided constraints. However, it is not readily apparent how we might validate whether a particular generator’s output satisfies this coverage requirement. Typically, developers must rely on manual inspection and post-mortem analysis of test runs to determine if the generator is providing sufficient coverage; these approaches are error-prone and difficult to scale as generators become more complex. To address this important concern, we present a new refinement type-based verification procedure for validating the coverage provided by input test generators, based on a novel interpretation of types that embeds “must-style” underapproximate reasoning principles as a fundamental part of the type system. The types associated with expressions now capture the set of values guaranteed to be produced by the expression, rather than the typical formulation that uses types to represent the set of values an expression may produce. Beyond formalizing the notion of coverage types in the context of a rich core language with higher-order procedures and inductive datatypes, we also present a detailed evaluation study to justify the utility of our ideas.},
  journal    = {Proc. ACM Program. Lang.},
  month      = {jun},
  articleno  = {157},
  numpages   = {24},
  keywords   = {property-based testing, refinement types, underapproximate reasoning}
}

@article{Synquid,
  author     = {Polikarpova, Nadia and Kuraj, Ivan and Solar-Lezama, Armando},
  title      = {Program Synthesis from Polymorphic Refinement Types},
  year       = {2016},
  issue_date = {June 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {6},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2980983.2908093},
  doi        = {10.1145/2980983.2908093},
  abstract   = {We present a method for synthesizing recursive functions that provably satisfy a given specification in the form of a polymorphic refinement type. We observe that such specifications are particularly suitable for program synthesis for two reasons. First, they offer a unique combination of expressive power and decidability, which enables automatic verification—and hence synthesis—of nontrivial programs. Second, a type-based specification for a program can often be effectively decomposed into independent specifications for its components, causing the synthesizer to consider fewer component combinations and leading to a combinatorial reduction in the size of the search space. At the core of our synthesis procedure is a newalgorithm for refinement type checking, which supports specification decomposition. We have evaluated our prototype implementation on a large set of synthesis problems and found that it exceeds the state of the art in terms of both scalability and usability. The tool was able to synthesize more complex programs than those reported in prior work (several sorting algorithms and operations on balanced search trees), as well as most of the benchmarks tackled by existing synthesizers, often starting from a more concise and intuitive user input.},
  journal    = {SIGPLAN Not.},
  month      = {jun},
  pages      = {522–538},
  numpages   = {17},
  keywords   = {Program Synthesis, Predicate Abstraction, Refinement Types, Functional Programming}
}

@article{Refinement,
  author     = {Vazou, Niki and Seidel, Eric L. and Jhala, Ranjit and Vytiniotis, Dimitrios and Peyton-Jones, Simon},
  title      = {Refinement Types for Haskell},
  year       = {2014},
  issue_date = {September 2014},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {49},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2692915.2628161},
  doi        = {10.1145/2692915.2628161},
  abstract   = {SMT-based checking of refinement types for call-by-value languages is a well-studied subject. Unfortunately, the classical translation of refinement types to verification conditions is unsound under lazy evaluation. When checking an expression, such systems implicitly assume that all the free variables in the expression are bound to values. This property is trivially guaranteed by eager, but does not hold under lazy, evaluation. Thus, to be sound and precise, a refinement type system for Haskell and the corresponding verification conditions must take into account which subset of binders actually reduces to values. We present a stratified type system that labels binders as potentially diverging or not, and that (circularly) uses refinement types to verify the labeling. We have implemented our system in LIQUIDHASKELL and present an experimental evaluation of our approach on more than 10,000 lines of widely used Haskell libraries. We show that LIQUIDHASKELL is able to prove 96\% of all recursive functions terminating, while requiring a modest 1.7 lines of termination-annotations per 100 lines of code.},
  journal    = {SIGPLAN Not.},
  month      = {aug},
  pages      = {269–282},
  numpages   = {14}
}
