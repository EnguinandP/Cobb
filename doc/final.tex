%%
%% This is file `sample-manuscript.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `manuscript')
%%
%% IMPORTANT NOTICE:
%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-manuscript.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
%%%% Small single column format, used for CIE, CSUR, DTRAP, JACM, JDIQ, JEA, JERIC, JETC, PACMCGIT, TAAS, TACCESS, TACO, TALG, TALLIP (formerly TALIP), TCPS, TDSCI, TEAC, TECS, TELO, THRI, TIIS, TIOT, TISSEC, TIST, TKDD, TMIS, TOCE, TOCHI, TOCL, TOCS, TOCT, TODAES, TODS, TOIS, TOIT, TOMACS, TOMM (formerly TOMCCAP), TOMPECS, TOMS, TOPC, TOPLAS, TOPS, TOS, TOSEM, TOSN, TQC, TRETS, TSAS, TSC, TSLP, TWEB.
% \documentclass[acmsmall]{acmart}

%%%% Large single column format, used for IMWUT, JOCCH, PACMPL, POMACS, TAP, PACMHCI
% \documentclass[acmlarge,screen]{acmart}

%%%% Large double column format, used for TOG
% \documentclass[acmtog, authorversion]{acmart}

%%%% Generic manuscript mode, required for submission
%%%% and peer review
\documentclass[review, sigplan]{acmart}
\usepackage{listings}
\usepackage{cleveref}
%% Fonts used in the template cannot be substituted; margin
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
%\AtBeginDocument{%
%  \providecommand\BibTeX{{%
%    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
%\setcopyright{acmcopyright}
%\copyrightyear{2018}
%\acmYear{2018}
%\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
%\acmConference[Conference acronym 'XX]{Make sure to enter the correct
%  conference title from your rights confirmation emai}{June 03--05,
%  2018}{Woodstock, NY}
%
%  Uncomment \acmBooktitle if th title of the proceedings is different
%  from ``Proceedings of ...''!
%
%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
% June 03--05, 2018, Woodstock, NY}
%\acmPrice{15.00}
%\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Cobb: Synthesis of Test Input Generators with Coverage Types}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Patrick LaFontaine}
\author{Anxhelo Xhebraj}
\author{David Deng}
%\email{}
%\affiliation{%
%    \institution{Purdue University}
%    \streetaddress{}
%    \city{}
%    \state{}
%    \country{USA}
%    \postcode{}
%}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{LaFontaine et al.}

\newcommand\todo[1]{\textcolor{red}{#1}}

%\begin{abstract}
%    This thing is cool
%\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
%\begin{CCSXML}

%\end{CCSXML}



%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
%\keywords{Do, Not, Us, This, Code, Put, the, Correct, Terms, for, Your, Paper}


%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
% Describe the high-level problem you were tackling

Synthesizing test input generators that satisfy a given coverage specification.

Addressing a gap left between type-theoretic but over-approximate synthesis
techniques and

\section{Overview}
% Recap any relevant existing work on this problem, give a high-level
% description of your solution, and summarize the relationship of how your
% solution relates to previous work. Include concrete examples(if applicable),
% that illustrate your solution

\subsection{Property-Based Testing}
A wide range of methods exist to ensure software safety. On the one hand, random testing or fuzzing uses random input to discover, but with the drawback that bugs requiring complex input may not be easily discovered; on the other hand, formal verification provides full safety guarantee, but it requires manual work to prove that the program is safe. 

Property-based testing stands in the middle ground between random testing and formal verification, in that the input generation is guided by the interested property, specified by programmers as logical predicates. This allows the programmers to guide the generated input using the testing predicate, allowing it to discover more intricate bugs, at the same time leveraging automation using SMT solvers to alleviate manual effort.

\subsection{Bottom-Up Synthesis}
We are taking ideas from bottom-up synthesis by starting from the leaf node. Although bottom-up synthesis (citation?) are often inductive and example-based, we use a deductive approach that is based on underapproximate type-checking to ensure correctness of the synthesized program.

\subsection{Deductive synthesis}

\subsection{Coverage Types}

Coverage Types~\cite{Poirot}

\subsection{Our Solution}

Coverage + bottom up + test input generators

Deductive synthesis with recursive specifications + bottom up

The intuition behind blocks, covering subsections of the program space. Small
depth programs as contrasted by long traces needed in inductive synthesis.

\section{Implementation}
% Provide key technical details about your solution, e.g. your toplevel
% algorithm, aprecise encoding of your problem in logic, etc.
We have implemented our solution as a bottom-up deductive synthesizer called
Cobb~(\url{https://github.com/Pat-Lafon/Cobb}).
Internally the algorithm uses Poirot for guiding the synthesis and pruning
the search space.

The program requires the user to specify the refined signature of the function
they would like to synthesize and a set of ``components'' and types
that should be used for enumerating terms.
Note that the components should have their refined types specified as
well.

An example of the initial information that the user provides
is shown below.

\begin{align*}
& T := \textsf{bool} \mid \textsf{int} \mid \textsf{int list} \\
& \text{Seed} := \textsf{bool\_gen}() \mid 0 \mid 1 \mid \textsf{int\_gen()} \mid \textsf{nil} \mid \textsf{list\_gen()} \\
& \text{Component} := \\
&\  \mid +: \textsf{int} \rightarrow \textsf{int} \rightarrow \textsf{int}\\
&\  \mid -: \textsf{int} \rightarrow \textsf{int} \rightarrow \textsf{int}\\
&\  \mid \leq: \textsf{int} \rightarrow \textsf{int} \rightarrow \textsf{bool} \\
&\  \mid \textsf{cons}: \textsf{int} \rightarrow \textsf{int list} \\
& \dots
\end{align*}
The types that should be used in the synthesis are
booleans, integers and lists of integers.
Seeds are elementary constructors such as 0, 1, and \textsf{nil}
but also non-deterministic applications of generators of values of
base types.

Components are functions or constructors.
All elements needed for the synthesis must have all the signatures
that are needed for Poirot to be able to check them.
Fortunately, by leveraging Poirot we reduce the overhead needed for setting
up the synthesis by reusing key lemmas and properties of common
data-types provided by its codebase already.

\todo{Load in various files}

Cobb additionally supports the generation of recursive functions.
We achieve this by adding the signature of the function being
generated in the pool of components available for use,
no different from standard typing of recursive bindings in non-refined
type-systems.
However, an additional constraint is added to the return type
of the function's specification to ensure that only applications
where at least one argument is structurally decreasing are formed.

\todo{Set typechecker global state, initialize starting seeds: constants, variables,
0-arity functions and constructors, and unit generators. Setting up component
abstractions.
}

Once seeds, components, and self-application with structurally decreasing
arguments is setup, the synthesis algorithm begins by enumerating
all terms up to a target level\footnote{The level of a node is what would
be commonly referred to as height in the tree. But since
we are constructing trees bottom-up we prefer the term level} specified by the user.
\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily, mathescape, numbers=left, numbersep=3pt]
def synth(seeds, components, tgt_sign, tgt_l):
 blocks = seeds
 for l in range(tgt_l):
   current_level = apply(components, blocks)
   # Prune redundant programs
   for p1, p2 in product(current_level, blocks):
     if coverage(p1) == coverage(p2): $\label{line:cvgcheck}$
       current_level.remove(p1)
   blocks = current_level + blocks

 return join(blocks, tgt_sign)
\end{lstlisting}
At level $\ell + 1$, we enumerate all blocks of height $\ell + 1$ by applying
the components to the blocks of level $i \leq \ell$.
Accordingly, at least one of the arguments must be of height $\ell$ to produce
a tree of height $\ell + 1$.
When building new terms in \lstinline[basicstyle=\small\ttfamily]|apply|
we ensure that components are applied only to \emph{simply well-typed} terms
to avoid expensive SMT calls for trivially simply ill-typed terms.

\begin{lstlisting}[language=Python, basicstyle=\small\ttfamily, mathescape, numbers=left, numbersep=3pt]
def apply(components, blocks):
 for c in components:
   argss = product_filter(blocks, c.arg_types)
   for args in argss:
      block = $'${ c(*args) }
      # Skip block if covered by argument
      if any(coverage(block) <= coverage(arg) $\label{line:cvginc}$
            for arg in args):
        continue
      yield block
\end{lstlisting}

Therefore, \lstinline[basicstyle=\small\ttfamily]|product_filter|
generates all potential arguments sequences \lstinline|argss|
that a component can be applied to, to produce a new simply well-typed
term of height $\ell + 1$.

There are two key optimizations we perform:
(1) when building a new block in \lstinline[basicstyle=\small\ttfamily]|apply|,
we make sure that it has an increased coverage with respect to its arguments (\Cref{line:cvgcheck}).
This is needed to avoid spurious terms such as
\lstinline[basicstyle=\small\ttfamily]|int_gen() + int_gen()|.

\subsection{Representing AST Nodes for Typing}
\todo{
Converting seeds to blocks, anormal form and the use of typing contexts to carry
incremental typing state.
}

Similarly to other refinement-type checkers, Poirot uses
ANF to simplify checking of dependencies of return types on arguments.
The standard approach of bottom-up synthesis to work on ASTs would
be suboptimal -- inferring the types of new terms would require to
first translate them in ANF and then for the type-checker to traverse
the ANF term to ``unpack'' it into contexts while inferring intermediate
nodes to finally type the full tree.

Our solution instead relies on representing terms by their
typing contexts and a global term table that keeps track of
the term corresponding to each variable.
Consider the following ANF term.
\begin{lstlisting}[language=caml, basicstyle=\small\ttfamily]
let a = int_gen()
 let b = 2
   a + b
\end{lstlisting}
The only information we keep track of is its context

\begin{lstlisting}[language=caml, basicstyle=\small\ttfamily, mathescape]
{
 a: ${\color{blue}[}\nu: \textsf{int} \mid \textit{true}{\color{blue}]}$,
 b: ${\color{blue}[}\nu: \textsf{int} \mid \nu == 2{\color{blue}]}$
 c: ${\color{blue}[}\nu: \textsf{int} \mid \textit{true}{\color{blue}]}$
}
\end{lstlisting}
where \lstinline|c| is the type of the value resulting from the
ANF term.


Initializing a collection of blocks based on typing. Old and new maps

Incrementing/joining blocks together. Joining contexts/renaming, false coverage
types. Coverage equivalence as a parallel to observational equivalence

Iterating to a fixed depth

Splitting blocks into subtypes versus supertypes, computing joins over the
subtypes.

Choosing the tightest solution

extracting out the final program

\section{Summary of Results}
% Describe how you validated your approach: if you ran experiments to evaluate
% your approach. provide any data or results from those.

\section{Reflection}
% Describe any key design and implementation challenges; how you addressed them
% (what worked, what didn't, and why);and how this work could lead to a real
% tool or a full-length conference paper. What did you learn from doing this project?

Challenges with building on top of the hodge-podge of Poirot's code base.

Finding the right interactions between over and under approximate reasoning. Not
needing overapproximate subtyping to set an upper bounds. Needing blocks with
both over and under approximate types to account for the hybrid typing of arrow
types.

Unlike traditional bottom-up enumeration, you can't look for a solution at every
iteration. The simplest solution is probably the smallest one though that one will
be too general. For example, if you have the generic generator for the target
type, you have a solution to synthesis before you even start. We also need to
limit the number to SMT queries made as they begin to pile up and are expensive.
It seems like this should be easily parallelizable, especially with the release
of Ocaml 5.0 if the type checker has limited mutable state.

The original need for simpler generators arose out of not knowing enough about
the problem space. What actually needed addressing is when to partition the
input space.

Anything else?

\subsection{Possible Typechecker Bugs?}
In our project, the subtyping checks are largely treated as a black box. In the
coarse of using Poirot, we believe we may have ran into some issues that
impacted the correctness of our synthesizer.

\subsubsection{Let binding immediate shadowing}

\subsubsection{Measure issues? The singleton list}

\subsubsection{Structural decreasing constraint on the return type instead of the argument}

\section{Teamwork}
% A one-paragraph description of the individual team member's contributions

\subsection{Patrick}

\subsection{Anxhelo}

\subsection{David}

\section{Course Topics}
% A one-paragraph description of the course topics applied in the project
This project, through Poirot, makes heavy use of the SMT solver Z3. The
predicates of our type system are embedded in EUFA which is a decidable fragment
of first order logic. The principles of safety specifications and coverage
exploration share parallels with some topics covered like transition system
safety properties and exhaustive state space exploration.

% and a one-paragraph description (if applicable) of any topics that would have
% been useful but weren't covered in the course.
Program synthesis was a planned topic for this course but unfortunately not
covered due to time constraints. In particular, the subtopics of Component-Based
Synthesis and Deductive Synthesis would have been particularly relevant. For
example, covering Synquid or related Haskell synthesis projects. This course
could have gone further in discussing refinement types as a type-theoretic
approach to a decidable fragment of first order logic.

\begin{acks}
    Christopher Nolan for making Inception for whom's main character this tool is
    named after.
    Ashish Mishra who originally purposed the idea of a bottom-up synthesizer
    for coverage types and for allowing Patrick to sit in on his
    under-approximate synthesis meetings and under-approximate reading group.
    Zhe Zhou for the Poirot type checker and showing much patience in answering
    our questions about Poirot's implementation and Coverage Types in general.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{cobb}

\end{document}
\endinput
